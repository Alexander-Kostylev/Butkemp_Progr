/*
Виды алгоритмов:
1. Константые                -   O(1), O(2) ...
2. Логарифмические           -   бинарный поиск log(n)
3. Линейные                  -   O(n) - O(2*n) ...
4. Линейно-логарифмические   -   быстрая сортировка
5. Квадратные                -   пузырьковая сортировка, сортировка выбором, сортировка вставками
6. Кубические                -   трехмерные масиивы
*/

// Example 1. Написать программу, которая считает сумма чисел от 1 до N. (1 и 3 тип алгоритмов)

// Console.Clear(); // очистка сонсоли
// Console.WriteLine("Введите число: ");
// int n = int.Parse(Console.ReadLine()!);     //знаком "!" мы сооюбщаем программе что строка не будет равна null (берем насебя)  
// int n = Convert.ToInt32(Console.ReadLine()); // альтернативные вводи числа с консоли, через конверт строки в тип int32


// int result = 0;
// for (int i = 1; i <= n; i++)
// {
//     result += i;
// }
//Console.WriteLine($"Сумма всех чисел от 1 до {n} равна {result}");
// Console.WriteLine($"Сумма всех чисел от 1 до {n} равна {(1 + n) / 2.0 * n}");

//=============================================================
//Бинарный поиск (двоичный поиск) - 2й тип алгоритма
// Заганное число равно 67
// от 1 до 100
// число больше 50? - Да (от 50 до 100)
// число больше 75? - нет (от 50 до 75)
// число больше 62? - да (от 62 до 75)
// число больше 68? - нет (от 62 до 68)
// число больше 65? - да (от 65 до 68)  
// число больше 66? - Да (от 66 до 68)
// число больше 67? - нет (ответ 67)
// 7 попыток
// Сложность алгоритма бинарного поиска равен O(log2(n))
// log2(1000)=10
//=============================================================

//Найти элемент в массиве
// [34, 16, 896, -24, -875, 7, 57, 1, 3, 12], n-количество элементов в массиве
// Сложность O(n*log2(n)+O(log2(n)))

//==============================================================

// Быстрая сортировка   O(n*log2(n)   (Рекурсивный подход)

// [34,-10, 23, 5, 2, 1]
// 1. Выбирается опорный элемент (в  основном берется первый элемент массива)
// 2. Создается 2 массива. 1-й массив содержит элементы меньше опорного,
// 2-й массив содержит элементы больше или равные опорному
// после выбора последнего опорного элемента происходит рекурсивное сборка всего массива (от последнего к первому)

// опорный элемент равен 34         [-10, 1, 2, 5, 23, 34]
// [-10, 23, 5, 2, 1] + [34] +[]
// опоный элемент -10               [-10, 1, 2, 5, 23]
// [] + [-10] + [23, 5, 2, 1] 
// опорный элемент 23               [1, 2, 5, 23]
// [5, 2, 1] + [23] + []
// опорный элемент 5                [1, 2, 5]
// [2, 1] + [5] +[]
// опорный элемент 2                [1, 2]
// [1] + [2] +[]


